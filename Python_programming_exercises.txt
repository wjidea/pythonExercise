Three files are required for the exercises described here: fruits_veggies.txt, print_command_line_options.pl and maize_protein_sequences.fasta.

0.  Write a hello_world.py script.  Print "Hello world." to the terminal.

1.  Write a script that will read the fruits_veggies.txt file, one line at a time, and that will print to the terminal each line from the file.   

2.  Write a script that will read the fruits_veggies.txt file and that will print to the terminal only the lines of data that contain the word "red".  Use an "if statement" and the "in" function to do this.  The fruits_veggies_colors.txt file is a tab-delimited file.  Each line has a fruit/veggie name, a color, a price and a PLU code.  The columns are separated by tabs.

3.  Write a script that will read the fruits_veggies.txt file and that will print to the terminal only the names of the fruits/vegetables.  Use an "if statement" and the grouping function of regular expressions to match and grab the name of each fruit.

4.  Write a script that will read the fruits_veggies.txt file and that will print to the terminal only the names of "red" fruits/vegetables.  Use an "if statement" and the grouping function of the regular expression module to match and grab the fruit name and color from each line.  

5.  Write a script that will read the fruits_veggies.txt file and that will print to the terminal only the names of the fruits/vegetables.  This time, use the "split" function to parse out the fruit/veggie names from each line.  Note that "split" returns an tuple.  For simple cases like this you can assign the results from split into an array variable or a list of scalars:

my_tuple = line_from_fruits_veggies.split()

(name, color, price, plu) = line_from_fruits_veggies.split()

 While the tuple result from split is convenient, when a line that is being split has 20 columns of data, writing out 20 unique variable names can be bothersome and dumping the results from split into an explicit tuple is less error-prone.

6.  Write a script that will read the fruits_veggies.txt file and that will print to the terminal just the PLU code for each fruit/vegetable followed by the name of each fruit/vegetable.  Use a regular expression to match and capture in this script.

7.  Write a script that will read the fruits_veggies.txt file and that will print to the terminal just the PLU code for each fruit/vegetable and the name of each fruit/vegetable.  Use the "split" function to parse the fruit/veggie name and PLU code from each line.  The split command is usually the appropriate tool for parsing a tab-delimited line of data.  Writing complex regular expressions for long lines of data takes longer and is error-prone.  For the sake of becoming familiar with arrays, dump the results from the split function into an explicit tuple.

8.  Write a script that will read the fruits_veggies.txt file and that will print to the terminal just the PLU code for each fruit/vegetable and the name of each fruit/vegetable.  Use the "split" function to parse the fruit/veggie name and PLU code from each line.  However, instead of printing each line of output as soon as it is read and parsed from the input file, store the names and PLU codes in a dictionary.  Use the PLU codes as the keys and the names as the values.  After reading the entire file, use a "for" loop to iterate through the dicionary and to print the PLU codes and names to the terminal.  Like the input file, make the output file tab-delimited.  Does the order of the output match the order of the input?

9.  Rewrite the above script so that the output is written to a file called "plu_codes_and_fruit_veggie_names.txt".

10. Write a script that will read the fruits_veggies.txt file and that will write to a file the PLU code for each fruit/vegetable and the price for each.  Use a dictionary to store these data.  After the input file has been read, iterate through the dictionary using a for-loop and write the PLU codes and prices to a file called "plu_codes_and_fruit_veggie_prices.txt".

11. Write a script that will read the fruits_veggies.txt file and that will write to a file the PLU code for each fruit/vegetable and the color for each.  Use a dictionary to store these data.  After the input file has been read, iterate through the dictionary using a for-loop and write the PLU codes and prices to a file called "plu_codes_and_fruit_veggie_colors.txt".

12. Write a script that will read the plu_codes_and_fruit_veggie_names.txt and plu_codes_and_fruit_veggie_prices.txt files and write a file that contains the fruit/veggie names and prices without PLU codes.  Read the plu_codes_and_fruit_veggie_names.txt file, parse the PLU codes and fruit/veggie names and store these data in a dictionary.  Use the PLU codes as the dictionary keys.  Read the plu_codes_and_fruit_veggie_prices.txt file, parse the PLU codes and fruit/veggie prices and store these data in a second dictionary.  Use the PLU codes as the dictionary keys.  The keys in these two dictionaryes should be identical.  Iterate through one dictionary using a for-loop.  Use each PLU code to obtain the fruit/veggie name from one dictionary and the price from the second dictionary.  Print the results to a file.

13. Write a script that will read the plu_codes_and_fruit_veggie_names.txt, plu_codes_and_fruit_veggie_prices.txt and plu_codes_and_fruit_veggie_colors.txt files and that will write a file that contains the names and prices of just the red fruits/veggies.  Read the plu_codes_and_fruit_veggie_names.txt file, parse the PLU codes and fruit/veggie names and store these data in a dictionary.  Use the PLU codes as the dictionary keys.  Read the plu_codes_and_fruit_veggie_prices.txt file, parse the PLU codes and fruit/veggie prices and store these data in a second dictionary.   Use the PLU codes as the dictionary keys.  Read the plu_codes_and_fruit_veggie_colors.txt file, parse the PLU codes and fruit/veggie colors and store these data in a third dictionary.  Use the PLU codes as the dictionary keys.  The keys in these three dictionaryes should be identical.  Iterate through one dictionary using a foreach loop.   Use each PLU code to obtain the fruit/veggie name from one dictionary, the price from the second dictionary and the color from the third dictionary.  Print the results for red fruits/veggies to a file.

14. Write a script that will read the plu_codes_and_fruit_veggie_names.txt, plu_codes_and_fruit_veggie_prices.txt and plu_codes_and_fruit_veggie_colors.txt files and that will write a file that contains the names and prices of just the red fruits/veggies that cost more than $0.20.  Read the plu_codes_and_fruit_veggie_names.txt file, parse the PLU codes and fruit/veggie names and store these data in a dictionary.  Use the PLU codes as the dictionary keys.  Read the plu_codes_and_fruit_veggie_prices.txt file, parse the PLU codes and fruit/veggie prices and store these data in a second dictionary.   Use the PLU codes as the dictionary keys.  Read the plu_codes_and_fruit_veggie_colors.txt file, parse the PLU codes and fruit/veggie colors and store these data in a third dictionary.  Use the PLU codes as the dictionary keys.  The keys in these three dictionaryes should be identical.  Iterate through one dictionary using a for-loop.   Use each PLU code to obtain the fruit/veggie name from one dictionary, the price from the second dictionary and the color from the third hash.  Print the results for red fruits/veggies that cost more than $0.20 to a file.  You will have to use string formatting to print these results.

15. If you have not yet discovered the argparse module, read about it: https://docs.python.org/2/howto/argparse.html and https://docs.python.org/2/library/argparse.html.  Rewrite exercise 14 to accept flagged parameters from the command line.  See the example script: print_command_line_options.py.  Your new script should accept the names of each input file and a name for the output file.  Always use command line parameters.  Never hard-code file names or paths into your scripts.  Getopt is the beeâ€™s knees.  Learn it, love it, use it.  Always.  Always.

Attempting to read from files that don't exist will cause a script to fail.  If the non-existent file is only accessed 75% of the way through the script, it may take some time before the script will fail.  It is best to discover these problems immediately.  Use the isfile() function in the os.path module to test whether a file exists or not.  If the output file does exist, the script should fail.  Unknowingly writing over an existing file may cause tears.  Always test all files.

16. Why are flagged parameters important?  Add two parameters to the above script.  One parameter will indicate a color, and the other parameter will indicate a price.  Use the values of these two parameters to filter which data are printed in the output file.  The other benefit of command line parameters is that you can copy a command line call to your notes and you will always know exactly what input/output files were used and what any other parameters were used at that particular moment.  Hard-coded variables inside a script are not obvious in your notes.

Interlude - For files that are specified in command line options, always use the full file path for those files.  A file name without the location of the file in your extensive directory tree is nearly useless.

17. Write a script that will read the maize_protein_sequences.fasta file, one line at a time, and that will print to the terminal only the fasta header lines from that file.  Use an "if statement" and a regular expression to identify lines that contain headers.  

18. Write a script that will read the maize_protein_sequences.fasta file, one line at a time, and that will print to the terminal only those fasta header lines that contain the term "glycosyl".  Use an "if statement" and a regular expression to identify lines that contain the term "glycosyl".

19. Write a script that will read the maize_protein_sequences.fasta file, one line at a time, and that will print to the terminal only those fasta header lines that contain the term "glycosyl" but not the term "groups".  Use one "if statement" and a regular expression to match "glycosyl" and a second if statement inside the first if statement to exclude matches to "groups".  Python also has the convenient "in" and "not in" matching functions.  Rewrite the if-conditional to use the "in" and "not in" matching functions.

20. Rewrite the above script so that only a single "if statement" is used to test for both the presence of "glycosyl" and the absence of "groups".  Use the logical "and" operator and two regular expressions in the if-conditional.  What does the "or" operator do?  Try rewriting the script to perform matches on different sets of terms using different boolean operators.  (eg. "black and white", "black or white", "(black and white) or blue", "black and (white or blue)".

21. The sequences in the fasta file, maize_protein_sequences.fasta, are split over multiple lines.  Write a script that will read this file and that will print the sequence headers followed by a single line of sequence.  Use an if-else statement to do this.

22. The sequence headers in the fasta file have identifiers that are in Genbank format (gi|226505152|ref|NP_001151321.1|).  Write a script that reads the maize_protein_sequences.fasta file and that prints to file only those sequences whose accession ids start with "NP".  For the output file, provide headers that only contain the accession id for the sequences.  There are a number of ways to deal with this task.  Use a dictionary to store the sequences.  Use the accession ids as the keys in the dictionary and the sequences as the values.  Read and store all sequences in the dictionary.  After completely reading through the input file, iterate through the dictionary to identify those sequences with accession ids that begin with "NP", and print those data to the output file.

23. Rewrite the above script.  Use different logic this time.  Instead of reading all sequences into a hash and then printing those with the appropriate accession ids.  Print the sequences as the appropriate accession ids are identified.  To do this, make use a logical flag.  This will be a variable that will indicate whether or not the last observed accession id started with "NP".  Set the variable to 0 for false and 1 for true.  Only print sequence when the logical flag is true.

Upcoming exercises will have a series of tasks for parsing blast output, and the logic will become more twisted.

24. You will run blast on a medium sized set of sequences.  You will perform a blastn alignment of Populus tremuloides transcript assembly sequences against the transcripts from the Arabidopsis thaliana gene set.

While everyone uses blast alignments, most people do not really think about how the program actually works.  There is an excellent book called "BLAST" by Korf, Yandell and Bedell that explains blast in excrutiating detail.  I've only found one reasonable online blast tutorial.
http://www.ncbi.nlm.nih.gov/books/NBK1734/

Download this set of Populus tremuloides transcript assembly sequences.

ftp://ftp.plantbiology.msu.edu/pub/data/BFGR/release_3/PUTs/Populus_tremuloides.mRNA.PUT_filtered.fasta.gz

Also download this Arabidopsis thaliana transcript sequences.

ftp://ftp.plantbiology.msu.edu/pub/data/BFGR/release_3/model_genome_sequences/Arabidopsis_thaliana_transcripts.fasta.gz

You can unzip these files using the gunzip command in a terminal window.

You will run blast from the command line using the NCBI version of blast.  On your Ubuntu virtual machine, the NCBI blast programs have already been installed.  You will need to create a blast database from the Arabidopsis thaliana transcript sequences, and then you can run blastn using the Populus tremuloides sequences as the queries.

The program that is used to create the blast database is called "formatdb".
The blast program is called "blastall".

For both of these programs, you can display all of their command line options by displaying their man-pages (manual pages).  To do this use the "man" function.

> module load BLAST/2.2.26
> blastall  --help
> formatdb  --help

First create a blast database from the arabidopsis sequences.

formatdb  -i Arabidopsis_thaliana_transcripts.fasta -n arab_nuc  -p F -t arab_nuc

This will create three files called arab_nuc.nhr, arab_nuc.nin and arab_nuc.nsq

To run blast using the P. tremuloides sequences as queries:
blastall -b 100 -v 100 -p blastn -d arab_nuc  -i Populus_tremuloides.mRNA.PUT_filtered.fasta -o ara_v_pop_blastn_results.txt

Report back the meaning of each of the command line options used in the formatdb and blastall commands given above.

Review the description of the blast output.
http://etutorials.org/Misc/blast/Part+III+Practice/Chapter+6.+Anatomy+of+a+BLAST+Report/6.1+Basic+Structure/

Write a script that will extract just those results that have e-values better than 1e-10.  The output should include the name of the query sequence and the one-line results for each hit sequence that has an e-value better than the cutoff.

25.  The file called Artificial_population_genotype_data.txt contains artificial genotype data on F2 individuals from a cross between parental cultivars (in this case B73 and Mo17).  The file also contains genotype calls for the parents.  Note that the genotype calls for the parents are not uniform.  B73 is designated as an "A" for some loci, but for other loci, B73 is designated as a "B".  It would be convenient if B73 was always designated as "A".  

Write a script that will change the designations of B73 alleles from "B" to "A".  (For the non-geneticists, this means that for loci where B73 is currently designated as "B", not only B73 but all other individuals must be changed from "B" to "A" and vice-versa for Mo17 and individuals that are currently designated as "A".)

Also in this script, output a transposed version the final matrix.  That is, make the columns into rows and the rows into columns.

26.  Write a script that uses the Biopython modules called SeqIO and Seq to read the maize peptide fasta file.  Print each sequence id, the sequence length, the sequence description and the actual sequence to the terminal window using the bioperl functions.  

Note that unless you have Biopython installed on your Mac, you will have to run scripts that use Biopython on one of our servers.  You will also need to load the appropriate modules to run python scripts as well as to have access to Biopython.

module load python/2.7.9
module load Biopython/1.65

http://biopython.org/wiki/Biopython
http://biopython.org/wiki/Documentation
http://biopython.org/DIST/docs/tutorial/Tutorial.html  <<<<< Chapters 1, 2, 3, 5

27.  Write a script that uses the Biopython module called SeqIO to read the maize peptide fasta file.  Store each sequence object in a hash using the sequence id as a key.  After all of the sequences from the hash file have been stored in the hash, print to the terminal the sequence id and lengths of each sequence in the hash.

28.  Write a script that uses the Biopython SeqIO library to sort the maize peptide sequences into two seperate fasta files. One file will have sequences less than 300 amino acids, one file will have sequences greater than or equal to 300 amino acids.  Use SeqIO for writing to the new files instead of printing the results using a file handle.

29.  Write a script that uses the Biopython SeqIO library to create a fasta file of the first 50 amino acids from each maize peptide sequence.  Since the new file will contain new sequences, the headers for each sequence should have a new unique accession and some sort of informative description.  Use SeqIO for writing to the new files instead of printing the results using a file handle.

30.  Write a script that will use the Biopython SearchIO library to parse the blast result file from exercise 26.  The script should write a tab-delimited output file that contains the name of the blast database, the name of the query sequence, the length of the query sequence, the name of the best hit sequence, the length of the best hit sequence, the number of hsps for the best hit, and the score of the alignment with the best hit.  If there are two or more equally best hits, the data from both should be written to the file.

http://biopython.org/DIST/docs/tutorial/Tutorial.html  <<<< See Chapter 8. BLAST and other sequence search tools (experimental code)
http://biopython.org/DIST/docs/api/Bio.SearchIO.BlastIO-module.html

31.  We often summarize blast hits in terms of the percent coverage and percent identity because a high percent identity score for an alignment is meaningless if the percent coverage is low.  Write a script that will use Bio::SearchIO to parse the blast result file from exercise 27.  The script should write a tab-delimited file that contains the name of the query sequence, the name of the hit sequence, the percent identity for the alignment and the percent coverage of the alignment for all alignments that have at least 70% identity and 80% coverage.  Note that percent identity and percent coverage could be calculated relative to either the query or the hit sequence, but your script will calculate these values relative to the query sequence.  Also note that you must gather numbers from the HSPs in order to calculate percent identity and percent coverage correctly.

Extra credit:  Why can percent coverage and percent identity be greater than 100?  
